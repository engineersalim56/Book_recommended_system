# -*- coding: utf-8 -*-
"""books_recomended_System.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WGDd7aZYlnn2flUTvwJXFBO5qkG-LNBx
"""

# Importing the libraries
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt



# Loading the dataset
Bd = pd.read_csv('Books.csv')
Rd = pd.read_csv('Ratings.csv')
Ur = pd.read_csv('Users.csv')

# # Printing the shapes of the datasets
print(Bd.shape)
print(Rd.shape)
print(Ur.shape)

Bd



Rd

Ur

# Checking for missing values in Rd and Ur
print("Missing values in Ratings dataset:")
print(Rd.isnull().sum())

print("\nMissing values in Users dataset:")
print(Ur.isnull().sum())

# Checking for duplicated entries in Bd, Ur, and Rd
print("Duplicated entries in Books dataset:")
print(Bd.duplicated())

print("\nDuplicated entries in Users dataset:")
print(Ur.duplicated())

print("\nDuplicated entries in Ratings dataset:")
print(Rd.duplicated())

# Merging Rd and Bd datasets
new_df = Rd.merge(Bd)
new_df

# Merging Rd and Bd datasets based on ISBN
rating_with_name = Rd.merge(Bd, on="ISBN")
rating_with_name

rating_with_name['Book-Rating'] = pd.to_numeric(rating_with_name['Book-Rating'], errors='coerce')
rating_with_name['Book-Rating'].fillna(rating_with_name['Book-Rating'].mean(), inplace=True)
avg_rating_df = rating_with_name.groupby("Book-Title")['Book-Rating'].mean().reset_index()
avg_rating_df.rename(columns={'Book-Rating': 'average-ratings'}, inplace=True)
avg_rating_df



# Merging the number of ratings and average ratings DataFrames
popular_df = num_rating_df.merge(avg_rating_df, on="Book-Title")
popular_df

# Assuming 'number-ratings' is a column in the DataFrame 'popular_df'
filtered_popular_df = popular_df[popular_df["number-ratings"] >= 200]
filtered_popular_df

# Assuming 'rating' is a column in the DataFrame 'filtered_popular_df'
sorted_filtered_popular_df = filtered_popular_df.sort_values("average-ratings",ascending=False)

sorted_filtered_popular_df

popular_new_df=sorted_filtered_popular_df.merge(Bd,on="Book-Title")
popular_new_df

popular_new_df[["Book-Title", "Book-Author", "Image-URL-M", "number-ratings", "average-ratings"]]

popular_new_df["Image-URL-M"][0]

# now coolabrative based filtering

rating_with_name.groupby("User-ID")
rating_with_name

x=rating_with_name.groupby("User-ID").count()["Book-Rating"]>=50

# User based filtering

Literate_user=x[x].index
Literate_user

filter_rating=rating_with_name[rating_with_name['User-ID'].isin(Literate_user)]

# Book based rating

y=filter_rating.groupby("Book-Title").count()["Book-Rating"]>=50

famous_books=y[y]
famous_books.shape



final_rating=filter_rating[filter_rating['Book-Title'].isin(famous_books.index)]
final_rating

final_rating.drop_duplicates()

pt=final_rating.pivot_table(index="Book-Title",columns="User-ID",values="Book-Rating")
print("Pivot Table:")
pt

pt.fillna(0,inplace=True)
pt

from sklearn.metrics.pairwise import cosine_similarity



# similarity_score = cosine_similarity(pt).shape
similarity_score = cosine_similarity(pt)

similarity_score

np.where(pt.index=="Year of Wonders")[0][0]

def recommended_books(book_name):
    try:
        # Check if the specified book is in the user-item matrix
        index = np.where(pt.index == book_name)[0][0]
    except IndexError:
        print(f"The book '{book_name}' is not found in the dataset.")
        return

    print(f"Index of '{book_name}': {index}")

    # Ensure the index is within the valid range of the similarity_score tuple
    if index >= len(similarity_score):
        print(f"Error: Index {index} is out of range for similarity_score.")
        return

    # Getting the similarity scores for the specified book
    book_similarity = similarity_score[index]


    # Sorting the enumerated list of similar items based on similarity scores
    similar_items = sorted(enumerate(book_similarity), key=lambda x: x[1], reverse=True)

    # Extracting the top 5 recommended books
    top_recommendations = [pt.index[i[0]] for i in similar_items[1:6]]  # Exclude the input book itself

    # Printing recommended books
    print("Top 5 recommended books for", book_name, "are:")
    for book in top_recommendations:
        print(book)

recommended_books("The Notebook")

with open('recomender.pkl', 'wb') as file:
    pickle.dump((pt, similarity_score, popular_new_df), file)

